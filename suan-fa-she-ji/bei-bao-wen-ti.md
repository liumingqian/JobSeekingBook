# 背包问题

### 背包问题类型辨析

* 01背包：每样物品只有一个
* 完全背包：每样物品有无限多个
* 多重背包：每样物品个数不同,01背包的扩展，每个物品可以选0个或n个
* 混合背包
* 二维费用的背包问题：同时考虑体积和重量
* 分组背包：把物品分成若干组，每组内的物品只能选一件
* 背包问题方案数或最优方案
* 有依赖的背包问题（先修课）

### 01背包

```cpp
//双重循环遍历，只考虑前i个物品，对体积为1到j的情况下
//放入第i个物品或不放入第i个物品，检查f[i][j]的值是否要更新
for(int i=0;i<N;i++)
{
    for(int j=0;j<V;j++)
    {
        f[i][j]=f[i-1][j];
        if(j>v[i])
            f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
    }
}   
//答案：由于不一定装满背包，所以遍历取所有物品时每种体积的价值，取最大值
res=max(res,f[N][j]);     
```

{% hint style="danger" %}
初始化：将f全部初始化为0，则f\[i\]的含义为体积小于i的所有方案的最大价值。若f\[0\]初始化为0，其余初始化为-INF，则所有状态只能从f\[0\]转移而来，即适用于，"要求恰好装满背包"的问题。
{% endhint %}

#### 01背包优化

```text
//f[j]表示体积为j的情况下，最大价值是多少
for(int i=0;i<N;i++)
{
    for(int j=V;j>=v[i];j--)    //从后往前遍历
    //否则用第i个物品更新了体积为j的最大价值后，继续往后遍历到体积为j+v[i]时，用f[j]更新则造成重复放第i个物品
        f[j]=max(f[j],f[j-v[i]]+w[i]);
}
```

### 完全背包

```cpp
//由于每种体积可以重复选，对于每种体积，都要遍历所有物品，看再加一个这种物品能否更新最大值
//f[i]表示总体积是i的情况下，最大价值是多少
 for(int j=0;j<=V;j++)        //外层循环体积
    {
        for(int i=0;i<N;i++)        //内层循环物品
        {
            if(j>=items[i].first)
                f[j]=max(f[j],f[j-items[i].first]+items[i].second);
            res=max(res,f[j]);
        }
    }
//或 接上 01背包思路
for(int i=0;i<N;i++)
{
    for(int j=v[i];j<;j++)//从前往后遍历可以用到重复物品
        f[j]=max(f[j],f[j-v[i]]+w[i]);
}
```

### 多重背包

```text
//比01背包多循环一层物品个数就行了
```

