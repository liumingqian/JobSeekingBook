# 编译和连接

### 编译

编译器以一个cpp文件为单位进行编译

#### 预处理

输入：源程序（文本）

* 宏定义：替换\#define
* 条件编译指令：\#ifdef
* 头文件包含指令：将包含文件插入到该预编译的位置

输出：修改后的源程序（文本）

#### 编译

通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

输出：汇编程序（文本）

#### 汇编

* 此文件中生成符号表（函数和变量都是符号）

输出：可重定位目标程序（二进制）

### 链接

* **符号解析**：合并符号表，将目标文件中的符号引用和符号定义联系起来
* **重定位**：编译器和汇编器生成从地址0开始的代码和数据节，链接器通过把每个符号定义与一个存储器位置联系起来，修改所有对这些符号的引用，使他们指向正确的运行时存储器地址，从而重定位这些节

#### dll和lib

dll和lib的区别：

（1）lib是编译时用到的，dll是运行时用到的。如果要完成源代码的编译，只需要lib；如果要使动态链接的程序运行起来，只需要dll。

（2）如果有dll文件，那么lib一般是一些索引信息，记录了dll中函数的入口和位置，dll中是函数的具体内容；如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。使用静态编译的lib文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行。

（3）动态链接的情况下，有两个文件：一个是LIB文件，一个是DLL文件。LIB包含被DLL导出的函数名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到DLL文件。在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中相应函数代码的地址，从而节省了内存资源。DLL和LIB文件必须随应用程序一起发行，否则应用程序会产生错误。如果不想用lib文件或者没有lib文件，可以用WIN32 API函数LoadLibrary、GetProcAddress装载

输出：可执行程序（二进制）

### 前向声明

对于不完全类型只能定义其引用或指针。C++在分配对象之前必须看到类定义。声明类的指针是向编译器保证先用着这个类，编译时会看到完整的定义。

用处：

* 解决头文件环形引用的困境
* 一定程度上提高编译速度

### 内联函数（inline\)

调用内联函数时，并不真正的执行中断调用函数，保存运行状态并执行内联函数的过程，而是直接把内联函数代码嵌入程序的调用点，大大减少调用成员函数的时间开销，所以对于短小而常用的函数可以声明为内联函数。

```cpp
//声明一个内联函数
inline const string &  
shorterString(const string &s1, const string &s2)  
{  
return s1.size() <= s2.size() ? s1 : s2;  
}  
  
//那么当我们执行：  
cout << shorterString(s1, s2) << endl;  
//其实编译时会变成：  
cout << (s1.size() < s2.size() ? s1 : s2) << endl; 
```

编译器对内联函数有判断：如果不合理，就算声明了inline，编译器也作为普通函数处理。而类体内定义的成员函数如果不包含循环等控制结构，则编译器自动将其视为内联函数处理。

注意：如果在类体外定义类的内联成员函数，需要将类定义和该成员函数定义放在一个头文件中，否则编译时无法进行置换。

```cpp
class Student  
{  
   public : inline void display( );//声明此成员函数为内置函数  
   private :  
   int num;  
   string name;  
   char sex;  
};  

inline void Student::display( ) //在类外定义内置函数，需要和类定义放在同一文件中  
{  
   cout<<"num:"<<num<<endl;cout<<"name:"<<name<<endl;cout<<"sex:"<<sex<<endl;  
}
```

