# 继承、多态、封装

## 多态

虚函数是多态的基础，其调用方式是动态联编，即程序运行时才决定调用基类函数还是子类函数。代码实现上的表现为，用父类指针指向子类实例，通过父类指针调用实际子类的成员函数。

### 多态的方式

广义上的多态有三种：虚函数、函数重载、模板。

#### 虚函数（接口）

C++ 接口是使用抽象类来实现的，类中定义纯虚函数，实现该接口的类必须实现每个虚函数。

{% hint style="danger" %}
**注意**：

1. 构造函数和静态函数不能为虚函数
2. 被继承的类需要将析构函数声明为虚函数，否则在父类指针指向子类的时候容易造成内存泄漏（父类指针无法通过虚函数表定位到子类的析构函数，只能析构父类部分的成员）
{% endhint %}

{% hint style="info" %}
**虚函数表：**虚函数是通过一张虚函数表来实现的，虚函数表是一块连续的内存，每个内存单元中记录一个指令地址。虚函数表被类的所有实例共享，所有实例中都分配了指向这个表的指针的内存

**纯虚函数**：基类中不能给出有意义的实现，作用是为了提供一致的规范的接口

 **抽象类**：至少含有一个纯虚函数。抽象类是不能实例化的，但是可以声明指针和引用
{% endhint %}



#### 函数重载

#### 模板

#### 不具备多态性质的元素

* 默认参数：不可继承，也不具备多态，其绑定到当前对象接口的默认参数上 
* 静态成员和方法：可以被子类继承，但是不能被重写，无法形成多态

{% tabs %}
{% tab title="例1" %}
```cpp
class A
{
  public:
  A(){ printf(“A”);}
  ~A(){ printf(“~A”);
};
class B:public A
{
  public;
  B(){ printf(“B”);}
  ~B(){ printf(“~B”);}
};
  
int main()
{
  A*c = new B[2];
  delete[] c;
  return 0;
}
```

输出为：ABAB\`~A~A

解析：

删除指向派生类的基类指针时，派生类的析构函数没有被调用，只是调用了基类的析构函数，此时派生类将会导致内存泄漏。解决办法是_**将基类的析构函数声明为虚函数**_，此时在调用析构函数的时候是根据ptr指向的具体类型来调用析构函数，此时会调用派生类的析构函数。
{% endtab %}
{% endtabs %}

## 继承

### 三种类继承方式

![](../../.gitbook/assets/image%20%2815%29.png)

![](../../.gitbook/assets/image%20%2840%29.png)

![](../../.gitbook/assets/image%20%2839%29.png)

### 基类与派生类关系

* 基类指针和引用可以直接指向和引用派生类对象，并在使用虚函数时呈现多态特性
* 但基类指针或引用只能用于调用基类方法
* 派生类引用和指针不能指向基类对象和地址
* 派生类向基类赋值可以将派生对象的基类部分赋给基类对象
* 在派生类中使用作用域解析运算符调用基类方法

