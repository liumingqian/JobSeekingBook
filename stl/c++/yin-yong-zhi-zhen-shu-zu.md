# 引用、指针、数组

### 引用

* 没有空引用，引用创建时必须初始化，引用被初始化为引用一个对象后，不能再指到另一个对象（指针和引用的区别）
* 没有到引用的引用
* 没有指向引用的指针
* 没有引用的数组（引用创建的时候必须被初始化）

```cpp
int& a[3];//error
```

* 数组的引用：

```cpp
int (&array)[10];//首先是个引用，指向大小为10的int数组
```

#### 右值引用

ref：[从四行代码看右值引用](https://www.cnblogs.com/qicosmos/p/4283455.html)

解决的问题：

* 为临时对象[延长生存期](https://zh.cppreference.com/w/cpp/language/reference_initialization#.E4.B8.B4.E6.97.B6.E9.87.8F.E7.94.9F.E5.AD.98.E6.9C.9F)，避免临时对象的拷贝操作。
* 在模板参数中按参数的实际类型进行转发

到const的左值引用也可以延长对象生存期，但是不能修改了

```cpp
const int& r2 = 6; // okay ：到 const 的左值引用延长生存期 
r2 += 3; // 错误：不能通过到 const 的引用修改

string&& r3 = s1 + s1;      // okay ：右值引用延长生存期
r3 += "Test";               // okay ：能通过右值引用修改
T&& k = getVar();            //okay：避免了对象拷贝
```

右值引用不能绑定到左值。

```cpp
string s1 = "Test";	     //左值
string&& r1 = s1;        // 错误：不能绑定到左值
```

### 指针和引用

指针是一个值，保存的是它指向的内存，\*号使我们获取特定地址上保存的值。

```cpp
int x=5;
cout<<*(&x);//5
```

当声明一个指针的时候，为指针本身分配了内存，但指针的值（指针所指向的内存）是空的

```cpp
int *a;
cout << a <<" "<< &a << endl;//CCCCCCCC 008FFCBC
```

#### 指针传参

当传递指针的时候，实际上是按值传递，发生了值的拷贝，函数内的指针是一个临时变量。

```cpp
int main()
{
    int *a;
    cout << a <<" "<< &a << endl;//CCCCCCCC 008FFCBC
    test();
    cout << a <<" "<< &a << endl;//CCCCCCCC 008FFCBC
}

void test(int* a)
{
    //按值传递，指针的值是指针所指向的内存
    //这里声明了一个新的局部变量a，指向传入的指针所指向的内存，所以&a变化了
    cout << a <<" "<< &a << endl;//CCCCCCCC 008FFBE8
    a = new int[5];
    cout << a <<" "<< &a << endl;//00AE6C30 008FFBE8
}
```

最好在函数外分配内存，在函数内填充内存。

如果想在函数内为指针分配内存，要么用双重指针_\*\*要_么用指针的引用\*&做形参。

#### [指针和引用的区别](yin-yong-zhi-zhen-shu-zu.md#yin-yong)

* 指针有多重指针，引用没有多重引用
* 指针可以为空，可以多次赋值，引用必须初始化，不能为空

### 指针和数组

#### 指针和数组的相互转化

向函数传递数组的时候数组蜕化为指针，二维数组退化为数组的指针\(不会变成指针的指针）。

```cpp
//如果你向函数传递二维数组：
int array[NROWS][NCOLUMNS];
f(array);
//那么函数的声明必须匹配：
void f(int a[][NCOLUMNS]){ ... }
//或者
void f(int (*ap)[NCOLUMNS]){ ... }  /* ap是个数组指针 */
```

数组名可作为指针常量（数组和指针的关系）

#### 数组指针和指针数组的区别

```cpp
 //定义一个指针数组，数组中每个元素是一个指针
 //[]运算符优先级高，因此先与p结合，p[4]首先是一个数组，int*指明这是一个int*数组
int *p[4]; 

 //定义一个数组指针，该指针指向含4个元素的一维数组
 //（*p）优先级高，p首先是一个指针
int (*p)[4]; 
```

{% tabs %}
{% tab title="例1" %}
```cpp
int main()
{
    int m []={1,2,3,4,5,6,7,8,9,0};
    int(*p)[4]=(int(*)[4])m;
    printf(“%”,p[1][2]);
    return 0;
}
```

则代码输出为：7

_解析：_

1、int \(p\)\[4\]：表示行指针，单位移动量为4个int类型。即p+1，则一次移动4个int类型 

2、\(int \(\)\[4\]\)m：表示以数组指针类型组织m，每4个为一个数组 

3、这样一来，m为｛｛1，2，3，4｝，｛5，6，7，8｝，｛9，0， ， ｝｝，p指向第一行 

4、故p\[1\]\[2\]即（（p+1）+2），表示第二行第三个元素，为7
{% endtab %}
{% endtabs %}

#### 

