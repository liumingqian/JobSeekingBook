# 背包问题

### 背包问题类型辨析

* 01背包：每样物品只有一个
* 完全背包：每样物品有无限多个
* 多重背包：每样物品个数不同,01背包的扩展，每个物品可以选0-n个
* 混合背包：物品可能只有一个或无限多个或n个
* 二维费用的背包问题：同时考虑体积和重量
* 分组背包：把物品分成若干组，每组内的物品只能选一件
* 背包问题方案数或最优方案
* 有依赖的背包问题（先修课）

### 01背包

```cpp
//双重循环遍历，只考虑前i个物品，对体积为1到j的情况下
//放入第i个物品或不放入第i个物品，检查f[i][j]的值是否要更新
for(int i=0;i<N;i++)
{
    for(int j=0;j<V;j++)
    {
        f[i][j]=f[i-1][j];
        if(j>v[i])
            f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
    }
}   
//答案：由于不一定装满背包，所以遍历取所有物品时每种体积的价值，取最大值
res=max(res,f[N][j]);     
```

{% hint style="danger" %}
初始化：将f全部初始化为0，则f\[i\]的含义为体积小于i的所有方案的最大价值，答案直接返回f\[V-1\]就可以。若f\[0\]初始化为0，其余初始化为-INF，则所有状态只能从f\[0\]转移而来，即f\[V-1\]适用于"要求恰好装满背包"的问题，否则要遍历f数组，返回最大的f\[v\]
{% endhint %}

#### 01背包优化

```text
//f[j]表示体积为j的情况下，最大价值是多少
for(int i=0;i<N;i++)
{
    for(int j=V;j>=v[i];j--)    //从后往前遍历
    //否则用第i个物品更新了体积为j的最大价值后，继续往后遍历到体积为j+v[i]时，用f[j]更新则造成重复放第i个物品
        f[j]=max(f[j],f[j-v[i]]+w[i]);
}
```

### 完全背包

```cpp
//由于每种体积可以重复选，对于每种体积，都要遍历所有物品，看再加一个这种物品能否更新最大值
//f[i]表示总体积是i的情况下，最大价值是多少
 for(int j=0;j<=V;j++)        //外层循环体积
    {
        for(int i=0;i<N;i++)        //内层循环物品
        {
            if(j>=items[i].first)
                f[j]=max(f[j],f[j-items[i].first]+items[i].second);
            res=max(res,f[j]);
        }
    }
//或 接上 01背包思路
for(int i=0;i<N;i++)
{
    for(int j=v[i];j<;j++)//从前往后遍历可以用到重复物品
        f[j]=max(f[j],f[j-v[i]]+w[i]);
}
```

### 多重背包

```cpp
//比01背包多循环一层物品个数就行了
for(int i=0;i<N;i++)
{
    for(int j=V;j>=v[i];j--)    //从后往前遍历
    {
        for(int k=1;k<=s[i]&&k*v[i]<=j;k++)
            f[j]=max(f[j],f[j-k*v[i]]+k*w[i]);
    }
}
```

#### 多重背包的二进制优化

> 引入：
>
> Q：给一个数n，问最少把n拆成几个数，可以表示1-n的所有数？
>
> A：log2\(n\)上取整个，模拟十进制数的二进制表示。
>
> 如，对于10，将其拆成1（10-1=9）
>
>                                          2（9-2=7）
>
>                                          4（7-4=3）
>
>                                          ~~8（3-8&lt;0\)~~
>
> 则将10拆成1，2，4，3四个数一定可以表示从1-10的所有数

```cpp
//多重背包问题的原始做法是将每种物体的若干个都作为独立的物体放入背包，但是时间复杂度比较高
//根据上述的二进制思想，将每种的s个物体拆成log2(n)个，即可以01背包的方法判断每个物体选还是不选了。
for(int k=1;k<=s;k*=2)
{
    s-=k;
    items.push_back({v*k,w*k});
}
if(s>0) items.push_back({v*s,w*s});//先将s个物品拆分成log2(s)个

//后面与01背包相同
```

### 二维费用的背包

```cpp
//01背包的二维扩展
for(int i=0;i<N;i++)
{
    for(int j=V;j>=v[i];j--)
        for(int k=M;k>=m[i];k--)
            f[j][k]=max(f[j][k],f[j-v[i]][k-m[i]]+w[i]]);
}
```

### 分组背包

```cpp
//类似多重背包问题，只是对于每个组内的所有物体，决策选择哪个物体
for(int i=0;i<N;i++)    //N这里是组数
{
    int S;
    cin>>S;
    for(int s=0;s<S;s++)
        cin>>v[s]>>w[s];
    for(int j=V;j>=0;j--)
        for(int s=0;s<S;s++)
            if(j>=v[s]) f[j]=max(f[j],f[j-v[s]]+w[s]); 
}
return f[V];
```

