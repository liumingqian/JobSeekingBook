# 网络

### 域名、IP地址和Mac地址

#### mac地址

数据链路层使用的物理地址，是硬件厂商写在网卡硬件上的，计算机的唯一标识

#### ip地址

网络层以上使用的地址。IPv4标准中IP地址是一个32bit的数字，每字节表示一个0-255的数字。

#### ARP协议

进行ip地址到mac地址的转换

#### DNS服务

负责域名到ip地址的转换。一个域名可以对应多个IP地址。

#### ref

[Rpc服务和HTTP服务对比](https://blog.csdn.net/wangyunpeng0319/article/details/78651998)

[如何实现一个简单的rpc](https://www.jianshu.com/p/5b90a4e70783)

### OSI网络七层模型 <a id="OSI&#x7F51;&#x7EDC;&#x4E03;&#x5C42;&#x6A21;&#x578B;"></a>

（前三层基本可以合并）

* 第一层：应用层。定义了用于在网络中进行通信和传输数据的接口；
* 第二层：表示层。定义不同的系统中数据的传输格式，编码和解码规范等；
* 第三层：会话层。管理用户的会话，控制用户间逻辑连接的建立和中断；
* 第四层：传输层。格式化信息流，提供可靠的端到端的数据传输；
* 第五层：网络层。定义网络设备间如何传输数据；
* 第六层：链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输；
* 第七层：物理层。这一层主要就是传输这些二进制数据。

#### C/S架构

## TCP/IP协议

一个传输层协议族，包括IP协议、IMCP协议、TCP协议等。TCP/IP指的是TCP和IP协同工作，TCP负责应用软件（如浏览器）和网络软件间的通信，IP负责计算机间的通信

#### IP协议

是计算机间的无连接的通信协议。

### TCP协议

TCP用于应用程序之间的全双工通信。

#### Tcp连接的建立

三次握手后两方的初始序列号达成了统一，需要三次握手而不是两次可以避免网络拥堵的时候客户端超时重发，导致有多个连接请求抵达服务端，无法得到正确的初始序列号。

* 第一次：客户端发送请求，请求报文中包含同步标志位和初始序列号seq=x
* 第二次：服务器收到报文后同意链接，发出确认报文，序列号是x+1，并初始化一个自己的序列号seq=y
* 第三次：客户端收到确认后再次向服务器给出确认，发送序列号x+1，y+1，客户端进入建立连接的状态，服务器收到确认后也进入建立连接的状态

#### Tcp链接的释放

Tcp连接是双向的，前两次挥手用于断开一个方向的连接，后两次用于断开另一方向的连接

* 第一次：A觉得数据发送完了，可以断开连接，向B发送连接释放请求，并进入FIN-WAIT-1状态
* 第二次：B收到后通知相应的应用程序，进入CLOSE-WAIT状态，并向A发送连接释放的确认。A收到应答后会进入FIN-WAIT-2状态，等待B发送连接释放请求，此时A到B的连接已经释放，A不会再向B发送数据，B不会接收A的数据，但B仍可向A发送数据
* 第三次：B向A发送完所有数据后向A发送连接释放请求，并进入LAST-ACK状态
* 第四次：A收到释放请求后向B发送确认应答，此时A进入TIME-WAIT状态，该状态持续2MSL时间，如果该时间段内B没有重发请求，A就进入CLOSED状态，撤销TCB。B收到A的确认应答后也进入CLOSED状态，撤销TCB。
  * TIME-WAIT状态是为了保证B能收到A的应答，如果A发送的确认应答丢失了，B等待超时后就会重新发送释放请求，如果A直接CLOSED的话就不会做出任何响应，导致B永远无法正常关闭

#### TCP使用场景：

* FTP
* HTTP

arp协议

ICMP

UDP

TCP和UDP的区别

TCP和UDP的应用场景

time\_wait状态

#### HTTP协议

短链接

#### RPC\(远程过程调用）

是基于TCP/IP协议的一种服务。



RPC要解决的两个问题：

1. 解决分布式系统中，服务之间的调用问题。
2. 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑。

![&#x672C;&#x5730;&#x8FC7;&#x7A0B;&#x8C03;&#x7528;](../.gitbook/assets/image%20%2821%29.png)

![RPC](../.gitbook/assets/image%20%2840%29.png)

一个完整的RPC流程，可以用下面这张图来描述：  


![](//upload-images.jianshu.io/upload_images/7143349-a9db3c3c85194c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/263/format/webp)

其中左边的Client，对应的就是前面的Service A，而右边的Server，对应的则是Service B。  
 下面一步一步详细解释一下。

1. Service A的应用层代码中，调用了Calculator的add方法；
2. 这个Calculator实现类，内部并不是直接实现计算器的加减乘除逻辑，而是通过远程调用Service B的RPC接口，来获取运算结果，因此称之为**Stub**；
3. Stub怎么和Service B建立远程通讯呢？这时候就要用到**远程通讯工具**了，也就是图中的**Run-time Library**，这个工具将帮你实现远程通讯的功能，比如Java的**Socket**，也可以用基于Http协议的**HttpClient**，或者其他通讯工具类，都可以，**RPC并没有规定说你要用何种协议进行通讯**；
4. Stub通过调用通讯工具提供的方法，和Service B建立起了通讯，然后将请求数据发给Service B。需要注意的是，由于底层的网络通讯是基于**二进制格式**的，因此这里Stub传给通讯工具类的数据也必须是二进制，比如calculator.add\(1,2\)，你必须把参数值1和2放到一个Request对象里头（这个Request对象当然不只这些信息，还包括要调用哪个服务的哪个RPC接口等其他信息），然后**序列化**为二进制，再传给通讯工具类，这一点也将在下面的代码实现中体现；
5. 二进制的数据传到Service B这一边了，Service B当然也有自己的通讯工具，通过这个通讯工具接收二进制的请求；
6. 既然数据是二进制的，那么自然要进行**反序列化**了，将二进制的数据反序列化为请求对象，然后将这个请求对象交给Service B的Stub处理；
7. service B的stub解析请求对象，知道调用方要调的是哪个RPC接口，传进来的参数又是什么，然后再把这些参数传给对应的RPC接口，也就是Calculator的实际实现类去执行。很明显，如果是Java，那这里肯定用到了**反射**。
8. RPC接口执行完毕，返回执行结果，Service B以同样的流程把数据发给Service A，Service A反序列化执行结果 ，将结果返回给Application。

#### 浏览器输入一个地址回车之后都发生了啥？

1. 浏览器检查地址格式合法性
2. dns服务通过域名找出其ip地址
   1. 检查浏览器缓存
   2. 检查系统缓存
   3. 请求检查路由器缓存
   4. 请求DNS域名系统根服务器
3. 
