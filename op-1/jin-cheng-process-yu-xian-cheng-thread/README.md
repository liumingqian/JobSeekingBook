# 进程（process）与线程（thread）

## 概念

{% hint style="info" %}
**进程**：操作系统种拥有资源和独立调度的基本单位（通常一个程序对应一个进程），可理解为一个容器。

**线程**：负责执行进程地址空间中的代码，实现进程内部的并发，同一进程中的线程切换不会引起进程切换，线程切换开销小很多。

* 用户级线程： 由应用程序管理。应用程序启动后，操作系统给该程序分配一个进程号和内存空间等资源，程序运行在主线程。
* 内核级线程： 有关线程管理的工作由内核完成，应用程序没有代码，只能调用内核线程的接口。调度也由内核基于线程架构完成。内核可以将不同线程更好的分配到不同cpu，实现并行计算。 
* 组合方式实现多线程： 线程创建在用户空间，但多个用户级线程被映射到内核级线程上 
* 内核：负责整个硬件的驱动，以及提供各种系统所需的核心功能

**并发**：一个时间段内轮流执行多个操作。实现并发的方法包括多进程和多线程。 （两个队排同一个窗口，两队交替办理业务）

**并行**：两个或多个独立操作同时进行。（多个窗口同时处理业务）

**多道程序设计**：操作系统在内存中同时保存多个任务，当某作业等待某个任务，如 I/O 操作的完成。对于非多道程序系统，CPU 就会空闲；而对于多道程序系统，CPU 就会简单切换到另一个作业，以便执行。
{% endhint %}

## **进线程资源管理**

* _进程管理的资源_：多个线程共享

  * 地址空间
  * 全局变量（进程共享的数据）
  * 打开的文件描述符
  * 进程代码段
  * 进程控制块PCB：维护进程相关的信息

  进程之间是不能相互随意访问各自进程的内存的。

* _线程管理的资源_：
  * 自己的函数堆栈
  * 程序计数器：计算机执行指令时根据PC中存放的指令地址，将指令取到指令寄存器中。程序计数器存放下一条 指令所在单元的地址
  * 寄存器：可用来存储指令、数据和地址的高速存储部件，保存线程运行状态。
  * 线程控制块TCB：

堆：堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。

栈：是线程独有的，保存其运行状态和局部自动变量的，栈是thread safe的。

堆区和全局区的数据在多线程程序中需要加锁保护。

## **进线程通信IPC**

进程拥有自己的地址空间，进程内的线程对于其他进程不可见，同一进程的线程间可以通过_传递地址或全局变量_的方式传递信息。

* 单工通信：只支持数据在一个方向上的传输
* 半双工：数据可以在两个方向上传输，但不能同时传输
* 全双工：数据可以同时在两个方向上传输

### 进程间通信的几种方式

* 共享内存（高效）： 由一个进程创建，并将数据映射到一段能被多个进程访问的共享内存，用semaphore实现同步
* 套接字Socket（类似网络通信）：在操作系统内部注册一个端口，并监测是否有数据，其他进程直接写数据到该端口。网络通信其实也是一种进程分布在不同机器上的IPC。
* 管道：半双工通信，只能用于有共同祖先的进程间的通信
* 命名管道FIFO:允许无亲缘关系进程间的通信，创建一个用于连接一个读进程和一个写进程的共享文件
* 信号：比较复杂的通信方式，用于通知接收进程某个事件已经发生。

### **进程的同步和互斥**

同步进程间协调工作次序产生的直接制约关系，互斥是访问临界资源时只能一个进程访问，其他进程等待的间接制约关系。单核系统中并发只能互斥运行，多核系统可以采用同步的方式运行并发进程**。**

进程同步的方式包括以下几种：

**临界区**

同一时间只能被一个进程占用的资源是临界资源，如打印机。对临界资源的访问必须互斥进行，不能交叉进行，当临界资源被占用时，其他申请临界资源的进程会被阻塞。

同步机制所遵循的临界区使用原则：

* 空闲让进
* 忙则等待
* 有限等待：进程等待进入临界区的时间是有限的
* 让权等待：进程等待进入临界区时放弃CPU的使用

**互斥锁（mutex）和信号量（semaphore）**

* mutex **:** 协调对一个共享资源的单独访问。是semaphore的一种特殊情况。
* semaphore：为控制具有有限数量用户的资源而设计。在门口挂n把钥匙，进去的人就取一把，出来时再挂回原处。后来的人拿不到钥匙就只能在门口等待。

     数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。只有PV操作会改变信号量的值，值大于0代表剩余资源数量，值小于0代表正在等待使用该资源的进程数。

* PV操作：P操作原语和V操作原语组成（原语是不可中断的过程）。

    P请求资源，P操作导致信号量减1，如果信号量的值小于0，则该进程进入阻塞队列

    V释放资源，信号量加1，从阻塞队列头部取出一个进程进入就绪态

    PV操作成对出现，先进行P操作进入临界区，然后进行V操作出临

#### 事件

用来通知线程有一些事件已发生，从而启动后继任务的开始。

## 进程和作业调度算法

### 调度算法

* **先来先服务（FCFS）**：
  * **作业调度**：每次选择最先进入该队列的作业调入内存，为他们分配资源，创建进程，放入就绪队列
  * **进程调度**：每次从就绪队列中选最先进入该队列的进程，为之分配处理机（CPU）使其运行，该进程一直运行到完成，或阻塞，才放弃处理机
* **短作业优先**：选择估计运行时间最短的作业调入内存运行
* **高优先权调度**:处理机分配给就绪队列中优先权最高的进程
  * **非抢占式**：系统一旦把处理机分配给某个进程，就一直执行下去，直到完成，或当该进程放弃处理机，系统才将处理机分配给另一优先权最高的进程。
  * **抢占式**：进程执行期间如果出现了优先级更高的进程，要停止当前进程执行，分配给当前优先级最高的进程。采用这种算法时，每当系统中出现一个新的就绪进程，要将其优先级和当前运行的进程比较。
  * **优先级倒置（反转）**：指低优先级的任务持有高优先级任务所需要的共享资源，导致高优先级任务缺乏资源而受阻。
  * TODO:解决方案
* **高响应比优先:**短作业优先的不足是长作业的运行得不到保障，该方法使每个作业的优先级随等待时间增加而增加，使长作业等待一定时间后必然有机会分配到处理机。
* **时间片轮转**：进程按先来先服务的顺序排成一个队列，为队首进程分配时间片，时间片用完时进程中断，送往队尾。
* **多级反馈队列**：从高到低设置多个优先级不同的就绪队列，队列的优先级越高时间片越小。

  （1）进程进入内存后首先放到第一个队列的末尾，按FCFS原则排队等待调度，当轮到该进程执行时，如果他能在该时间片内完成，就可准备撤离系统，如一个时间片内未能完成，就转入第二队列末尾，依次类推。

  （2）当一个长作业被降到第n队列的时候，第n队列采取按时间片轮转的方式运行。

  （3）只有当地1-\(i-1\)队列为空的时候，才会调度第i队列中的进程运行。如果正在运行第i队列中的进程，此时有新的进程进入优先级更高的1-（i-1）队列，则新进程抢占处理机，当前正运行的进程回到第i队列的末尾

* 作业和进程有什么区别？

进程是一个程序对某个数据集的执行过程，是分配资源的基本单位。作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合。一个作业可由多个进程组成，至少由一个进程组成

### 进程状态

1. 运行态：进程正在实际占用cpu
2. 就绪态：表示已经获得资源，可以随时开始执行。进程被创建后进入就绪态，时间片用完、进程调度程序对进程进行调度也会由运行态转为就绪态
3. 阻塞态：进程等待某个外部事件发生，否则不能运行，如在执行P操作时没有申请到资源，或线程调用sleep方法

### 上下文切换

任务保存到再加载的过程

对于单核单线程的CPU，同一时刻只能执行一条CPU指令，上下文切换是将CPU资源从一个进程分配给另一个进程的机制，使计算机从用户角度看来可以并行运行多个进程。

> Q:切换时发生了什么？
>
> A:操作系统需要先存储当前进程的状态，包括内存空间指针，当前执行完的指令等，然后读入下一个进程的状态，执行此进程

### 死锁

设系统中有n个进程并发，每个进程都需要m个资源，则为使该系统不会死锁，最少要 n\*（m-1\)+1个资源

#### 产生死锁的条件

* 资源互斥
* 占有资源，请求并等待
* 不能剥夺别人的资源
* 循环等待

#### 避免死锁的静态策略

* 破解 占有并等待
  * 所有进程开始执行前必须一次性申请所有需要的资源
* 破解 循环等待
  * 加锁顺序：当多个线程需要相同的锁但按照不同的顺序加锁，就容易发生死锁，如果确保所有线程都按照相同的顺序获得锁，就不会发生死锁。只有获得了前面的锁之后才能尝试获取后面的锁，否则要一直等待前面的锁释放
  * 加锁时限：尝试获取锁的时候加一个超时时间，如果获取锁的过程中超过了时限，则放弃对该锁的请求。
* 破解 不可剥夺 
  * 若一个线程在时限内没有获得所有需要的锁，就自动回退并释放所有已经获得的锁，等待一段随机的时间再试。

#### 银行家算法

用来避免死锁。

假设银行家有100亿，现已经借出60亿，则再向他请求借款的话有些请求是安全的，有些则是不安全的，如按T-&gt;B-&gt;A或A-&gt;T-&gt;B的顺序都可行，但若先把剩下的50亿借给B则会死锁。

![](../../.gitbook/assets/image%20%2861%29.png)

银行家算法在资源分配前判断分配资源是否会让系统进入不安全状态（一个安全序列都找不到），以决定是否答应资源请求。安全状态一定不会死锁。

```cpp
//假设系统中有n个进程，m种资源
//Need:用一个n*m的二维矩阵表示所有进程对每种资源的最大需求数
//Allocation：用一个n*m矩阵表示当前对所有进程的资源分配情况
//Available：长度为m的一维数组表示对于没种资源，当前系统中还有多少可用资源

//request：长度为m的一维数组，表示当前进程Pi向系统请求资源的情况。

算法流程：
    1、判断进程请求数是否已经超过Need中的最大需求数，超过的话认为请求出错
    2、判断系统中是否还有足够资源能满足请求，没有就阻塞进程
    3、根据银行家算法，判断满足Pi的请求的话是否会导致系统进入不安全状态
        (1)当前剩余算法是否能满足进程最大需求，如果可以，将该进程加入安全序列，
        并把该进程持有的所有资源回收
        (2)不断重复(1)看是否能让所有进程都加入安全序列
```



### 特殊进程

#### 守护进程

也称为精灵进程，是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理发生的事件。

守护进程通常采用以d结尾的名字，表示Daemon

#### 

